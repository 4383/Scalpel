# (generated with --quick)

import __future__
import mlfromscratch.deep_learning.activation_functions
from typing import Any, Dict, NoReturn, Optional, Tuple, Type

ELU: Type[mlfromscratch.deep_learning.activation_functions.ELU]
LeakyReLU: Type[mlfromscratch.deep_learning.activation_functions.LeakyReLU]
ReLU: Type[mlfromscratch.deep_learning.activation_functions.ReLU]
SELU: Type[mlfromscratch.deep_learning.activation_functions.SELU]
Sigmoid: Type[mlfromscratch.deep_learning.activation_functions.Sigmoid]
SoftPlus: Type[mlfromscratch.deep_learning.activation_functions.SoftPlus]
Softmax: Type[mlfromscratch.deep_learning.activation_functions.Softmax]
TanH: Type[mlfromscratch.deep_learning.activation_functions.TanH]
activation_functions: Dict[str, type]
copy: module
division: __future__._Feature
math: module
np: module
print_function: __future__._Feature

class Activation(Layer):
    __doc__: str
    activation_func: Any
    activation_name: Any
    layer_input: Any
    trainable: bool
    def __init__(self, name) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def layer_name(self) -> str: ...
    def output_shape(self) -> Any: ...

class AveragePooling2D(PoolingLayer):
    padding: Any
    pool_shape: Any
    stride: Any
    trainable: bool
    def _pool_backward(self, accum_grad) -> Any: ...
    def _pool_forward(self, X_col) -> Any: ...

class BatchNormalization(Layer):
    X_centered: Any
    __doc__: str
    beta: Any
    beta_opt: Any
    eps: float
    gamma: Any
    gamma_opt: Any
    momentum: Any
    running_mean: Any
    running_var: Any
    stddev_inv: Any
    trainable: bool
    def __init__(self, momentum = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def initialize(self, optimizer) -> None: ...
    def output_shape(self) -> Any: ...
    def parameters(self) -> Any: ...

class ConstantPadding2D(Layer):
    __doc__: str
    padding: Any
    padding_value: Any
    trainable: bool
    def __init__(self, padding, padding_value = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def output_shape(self) -> Tuple[Any, Any, Any]: ...

class Conv2D(Layer):
    W: Any
    W_col: Any
    W_opt: Any
    X_col: Any
    __doc__: str
    filter_shape: Any
    input_shape: Any
    layer_input: Any
    n_filters: Any
    padding: Any
    stride: Any
    trainable: bool
    w0: Any
    w0_opt: Any
    def __init__(self, n_filters, filter_shape, input_shape = ..., padding = ..., stride = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def initialize(self, optimizer) -> None: ...
    def output_shape(self) -> Tuple[Any, int, int]: ...
    def parameters(self) -> Any: ...

class Dense(Layer):
    W: Any
    W_opt: Any
    __doc__: str
    input_shape: Any
    layer_input: Any
    n_units: Any
    trainable: bool
    w0: Any
    w0_opt: Any
    def __init__(self, n_units, input_shape = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def initialize(self, optimizer) -> None: ...
    def output_shape(self) -> Tuple[Any]: ...
    def parameters(self) -> Any: ...

class Dropout(Layer):
    __doc__: str
    _mask: Any
    input_shape: None
    n_units: None
    p: Any
    pass_through: bool
    trainable: bool
    def __init__(self, p = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def output_shape(self) -> Any: ...

class Flatten(Layer):
    __doc__: str
    input_shape: Any
    prev_shape: Any
    trainable: bool
    def __init__(self, input_shape = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def output_shape(self) -> Tuple[Any]: ...

class Layer:
    input_shape: Any
    def backward_pass(self, accum_grad) -> NoReturn: ...
    def forward_pass(self, X, training) -> NoReturn: ...
    def layer_name(self) -> str: ...
    def output_shape(self) -> NoReturn: ...
    def parameters(self) -> int: ...
    def set_input_shape(self, shape) -> None: ...

class MaxPooling2D(PoolingLayer):
    cache: Any
    padding: Any
    pool_shape: Any
    stride: Any
    trainable: bool
    def _pool_backward(self, accum_grad) -> Any: ...
    def _pool_forward(self, X_col) -> Any: ...

class PoolingLayer(Layer):
    __doc__: str
    layer_input: Any
    padding: Any
    pool_shape: Any
    stride: Any
    trainable: bool
    def __init__(self, pool_shape = ..., stride = ..., padding = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def output_shape(self) -> Tuple[Any, int, int]: ...

class RNN(Layer):
    U: Any
    U_opt: Any
    V: Any
    V_opt: Any
    W: Any
    W_opt: Any
    __doc__: str
    activation: Any
    bptt_trunc: Any
    input_shape: Any
    layer_input: Any
    n_units: Any
    outputs: Any
    state_input: Any
    states: Any
    trainable: bool
    def __init__(self, n_units, activation = ..., bptt_trunc = ..., input_shape = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def initialize(self, optimizer) -> None: ...
    def output_shape(self) -> Any: ...
    def parameters(self) -> Any: ...

class Reshape(Layer):
    __doc__: str
    input_shape: Any
    prev_shape: Any
    shape: Any
    trainable: bool
    def __init__(self, shape, input_shape = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def output_shape(self) -> Any: ...

class UpSampling2D(Layer):
    __doc__: str
    input_shape: Any
    prev_shape: Any
    size: Any
    trainable: bool
    def __init__(self, size = ..., input_shape = ...) -> None: ...
    def backward_pass(self, accum_grad) -> Any: ...
    def forward_pass(self, X, training = ...) -> Any: ...
    def output_shape(self) -> Tuple[Any, Any, Any]: ...

class ZeroPadding2D(ConstantPadding2D):
    __doc__: str
    padding: Any
    padding_value: int
    def __init__(self, padding) -> None: ...

def column_to_image(cols, images_shape, filter_shape, stride, output_shape = ...) -> Any: ...
def determine_padding(filter_shape, output_shape = ...) -> Optional[Tuple[Tuple[int, int], Tuple[int, int]]]: ...
def get_im2col_indices(images_shape, filter_shape, padding, stride = ...) -> Tuple[Any, Any, Any]: ...
def image_to_column(images, filter_shape, stride, output_shape = ...) -> Any: ...
