# (generated with --quick)

from typing import Any, Callable, NoReturn, TypeVar

doctest: module

_FuncT = TypeVar('_FuncT', bound=Callable)

class AndSpecification(CompositeSpecification):
    _one: Any
    _other: Any
    def __init__(self, one, other) -> None: ...
    def is_satisfied_by(self, candidate) -> bool: ...

class CompositeSpecification(Specification):
    def and_specification(self, candidate) -> AndSpecification: ...
    @abstractmethod
    def is_satisfied_by(self, candidate) -> None: ...
    def not_specification(self) -> NotSpecification: ...
    def or_specification(self, candidate) -> OrSpecification: ...

class NotSpecification(CompositeSpecification):
    _wrapped: Any
    def __init__(self, wrapped) -> None: ...
    def is_satisfied_by(self, candidate) -> bool: ...

class OrSpecification(CompositeSpecification):
    _one: Any
    _other: Any
    def __init__(self, one, other) -> None: ...
    def is_satisfied_by(self, candidate) -> bool: ...

class Specification:
    def and_specification(self, candidate) -> NoReturn: ...
    @abstractmethod
    def is_satisfied_by(self, candidate) -> None: ...
    def not_specification(self) -> NoReturn: ...
    def or_specification(self, candidate) -> NoReturn: ...

class SuperUserSpecification(CompositeSpecification):
    def is_satisfied_by(self, candidate) -> Any: ...

class User:
    super_user: Any
    def __init__(self, super_user = ...) -> None: ...

class UserSpecification(CompositeSpecification):
    def is_satisfied_by(self, candidate) -> bool: ...

def abstractmethod(funcobj: _FuncT) -> _FuncT: ...
def main() -> None: ...
